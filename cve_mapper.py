import argparse
import csv
import json
import os
import requests
from collections import defaultdict
from concurrent.futures import ThreadPoolExecutor, as_completed
from typing import NamedTuple, Optional, Dict, List, Tuple
from alive_progress import alive_bar


REDHAT_API = "https://access.redhat.com/labs/securitydataapi/cve/{}.json"
JSON_EXTENSION = ".json"
MAX_WORKERS = 10  # Adjust this value based on the number of parallel requests you want to make

class CVEResult(NamedTuple):
    """A class to store CVE results for Quay and RedHat."""
    quay: str
    redhat: Optional[str]

def check_cve(cve: str) -> Tuple[str, Optional[str]]:
    """
    Queries the Red Hat API for the threat severity level of the given CVE id.

    Args:
        cve (str): The CVE id.

    Returns:
        Tuple[str, Optional[str]]: A tuple containing the CVE id and the threat severity level, or None if the request failed.
    """
    rh_access_api = REDHAT_API.format(cve)
    response = requests.get(rh_access_api)
    if response.status_code == 200:
        return cve, response.json().get("threat_severity")
    else:
        return cve, None

def process_json(input_path: str, output_path: Optional[str] = None) -> None:
    """
    Processes the input JSON file(s) and generates output with the results.

    Args:
        input_path (str): Path to the input JSON file or directory containing JSON files.
        output_path (Optional[str], optional): Path to the output file. If None, the results will be printed to the console.
    """
    results: Dict[str, CVEResult] = {}
    files = get_files(input_path)
    if not files:
        print(f"Invalid input path: {input_path}")
        return

    # Process input files
    with alive_bar(len(files), title="Processing files") as bar:
        for file in files:
            with open(file) as f:
                data = json.load(f)
            process_violations(data, results)
            bar()

    # Fetch RedHat severities using parallel API requests
    with ThreadPoolExecutor(max_workers=MAX_WORKERS) as executor:
        cve_futures = {executor.submit(check_cve, cve): cve for cve, result in results.items() if not result.redhat}

        with alive_bar(len(cve_futures), title="Fetching RedHat severities") as bar:
            for future in as_completed(cve_futures):
                cve, redhat_severity = future.result()
                results[cve] = results[cve]._replace(redhat=redhat_severity)
                bar()

    write_output(results, output_path)

def get_files(input_path: str) -> List[str]:
    """
    Returns a list of JSON files from the input path.

    Args:
        input_path (str): The input path which can be a file or directory.

    Returns:
        List[str]: A list of JSON file paths.
    """
    if os.path.isdir(input_path):
        return [os.path.join(input_path, file) for file in os.listdir(input_path) if file.endswith(JSON_EXTENSION)]
    elif os.path.isfile(input_path):
        return [input_path]
    else:
        return []

def process_violations(data: dict, results: Dict[str, CVEResult]) -> None:
    """
    Processes the security violations in the input JSON data and updates the results dictionary.

    Args:
        data (dict): The input JSON data.
        results (Dict[str, CVEResult]): The results dictionary to update.
    """
    for item in data[0].get("violations"):
        severity = item.get("severity")
        for cve in item["cves"]:
            cve_to_check = cve.get("cve")
            if cve_to_check and cve_to_check not in results:
                results[cve_to_check] = CVEResult(severity, None)

def write_output(results: Dict[str, CVEResult], output_path: Optional[str]) -> None:
    """
    Writes the results to the output file or prints them to the console.

    Args:
        results (Dict[str, CVEResult]): The results dictionary.
        output_path (Optional[str]): The path to the output CSV file. If None, the results will be printed to the console.
    """
    if output_path:
        with open(output_path, "w", newline="") as csvfile:
            writer = csv.writer(csvfile)
            writer.writerow(["CVE", "Quay", "RedHat"])
            for cve, result in results.items():
                writer.writerow([cve, result.quay, result.redhat or ""])
    else:
        for cve, result in results.items():
            print(f"ID: {cve}, Quay: {result.quay}, RedHat: {result.redhat or 'Not found ⚠️'}")


def main() -> None:
    parser = argparse.ArgumentParser(description="CVE Mapper")
    parser.add_argument("input", help="Path to JSON file or directory containing JSON files")
    parser.add_argument("-o", "--output", help="Path to CSV file to write results to")
    args = parser.parse_args()

    process_json(args.input, args.output)


if __name__ == "__main__":
    main()
