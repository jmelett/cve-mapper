import argparse
import csv
import json
import os
import requests
from collections import defaultdict
from concurrent.futures import ThreadPoolExecutor, as_completed
from datetime import datetime
from typing import NamedTuple, Optional, Dict, List, Tuple
from alive_progress import alive_bar
from atlassian import Confluence


REDHAT_API = "https://access.redhat.com/labs/securitydataapi/cve/{}.json"
JSON_EXTENSION = ".json"
MAX_WORKERS = (
    10  # Adjust this value based on the number of parallel requests you want to make
)


class CVEResult(NamedTuple):
    """A class to store CVE results for Quay and RedHat."""

    quay: str
    redhat: Optional[str]
    description: Optional[str]
    statement: Optional[str]


def check_cve(cve: str) -> Tuple[str, Optional[str], Optional[str], Optional[str]]:
    """
    Queries the Red Hat API for the threat severity level of the given CVE id.

    Args:
        cve (str): The CVE id.

    Returns:
        Tuple[str, Optional[str]]: A tuple containing the CVE infos or None if the request failed.
    """
    rh_access_api = REDHAT_API.format(cve)
    response = requests.get(rh_access_api)
    if response.status_code == 200:
        data = response.json()
        return (
            cve,
            data.get("threat_severity"),
            data.get("bugzilla", {}).get("description"),
            data.get("statement"),
        )
    else:
        return cve, None, None, None


def create_confluence_page(
    base_url: str,
    api_token: str,
    space_key: str,
    input_path: str,
    output_path: Optional[str] = None,
) -> None:
    """
    Creates a Confluence page with the results table.

    Args:
        base_url (str): The base URL of the Confluence instance.
        api_token (str): The API token for authentication.
        space_key (str): The space key where the new page will be created.
        input_path (str): Path to the input JSON file or directory containing JSON files.
        output_path (Optional[str], optional): Path to the output file. If None, the results will be printed to the console.
    """
    confluence = Confluence(url=base_url, auth=(api_token, ""))
    results = process_json(input_path, output_path, return_results=True)

    # Generate a table in Confluence Storage Format
    table = "<table><tr><th>CVE</th><th>Quay</th><th>RedHat</th><th>Description</th><th>Statement</th></tr>"
    for cve, result in results.items():
        table += f'<tr><td>{cve}</td><td>{result.quay}</td><td>{result.redhat or "NOT_FOUND"}</td><td>{result.description or ""}</td><td>{result.statement or ""}</td></tr>'
    table += "</table>"

    # Create the Confluence page
    today_date = datetime.today().strftime("%Y-%m-%d")
    page_title = f"CVE Report {today_date}"
    existing_page = confluence.get_page_by_title(space_key, page_title)

    if existing_page:
        confluence.update_page(
            existing_page["id"], page_title, table, representation="storage"
        )
    else:
        confluence.create_page(
            space=space_key,
            title=page_title,
            body=table,
            parent_id=None,
            type="page",
            representation="storage",
        )


def process_json(
    input_path: str, output_path: Optional[str] = None, return_results: bool = False
) -> Optional[Dict[str, CVEResult]]:
    """
    Processes the input JSON file(s) and generates output with the results. If the create_confluence flag is set, it creates a Confluence page with the results table.

    Args:
        input_path (str): Path to the input JSON file or directory containing JSON files.
        output_path (Optional[str], optional): Path to the output file. If None, the results will be printed to the console.
        create_confluence (bool, optional): Flag to indicate whether to create a Confluence page with the results table. Defaults to False.
        confluence_args (Optional[Dict[str, str]], optional): Dictionary containing the Confluence API base URL, API token, and space key. Required if create_confluence is True.
    """
    results: Dict[str, CVEResult] = {}
    files = get_files(input_path)
    if not files:
        print(f"Invalid input path: {input_path}")
        return

    # Process input files
    with alive_bar(len(files), title="Processing files") as bar:
        for file in files:
            with open(file) as f:
                data = json.load(f)
            process_violations(data, results)
            bar()

    # Fetch RedHat severities using parallel API requests
    with ThreadPoolExecutor(max_workers=MAX_WORKERS) as executor:
        cve_futures = {
            executor.submit(check_cve, cve): cve
            for cve, result in results.items()
            if not result.redhat
        }

        with alive_bar(len(cve_futures), title="Fetching RedHat severities") as bar:
            for future in as_completed(cve_futures):
                cve, redhat_severity, description, statement = future.result()
                results[cve] = results[cve]._replace(
                    redhat=redhat_severity, description=description, statement=statement
                )
                bar()

    write_output(results, output_path)

    if return_results:
        return results
    return None


def get_files(input_path: str) -> List[str]:
    """
    Returns a list of JSON files from the input path.

    Args:
        input_path (str): The input path which can be a file or directory.

    Returns:
        List[str]: A list of JSON file paths.
    """
    if os.path.isdir(input_path):
        return [
            os.path.join(input_path, file)
            for file in os.listdir(input_path)
            if file.endswith(JSON_EXTENSION)
        ]
    elif os.path.isfile(input_path):
        return [input_path]
    else:
        return []


def process_violations(data: dict, results: Dict[str, CVEResult]) -> None:
    """
    Processes the security violations in the input JSON data and updates the results dictionary.

    Args:
        data (dict): The input JSON data.
        results (Dict[str, CVEResult]): The results dictionary to update.
    """
    for item in data[0].get("violations"):
        severity = item.get("severity")
        for cve in item["cves"]:
            cve_to_check = cve.get("cve")
            if cve_to_check and cve_to_check not in results:
                results[cve_to_check] = CVEResult(severity, None, None, None)


def write_output(results: Dict[str, CVEResult], output_path: Optional[str]) -> None:
    """
    Writes the results to the output file or prints them to the console.

    Args:
        results (Dict[str, CVEResult]): The results dictionary.
        output_path (Optional[str]): The path to the output CSV file. If None, the results will be printed to the console.
    """
    if output_path:
        with open(output_path, "w", newline="") as csvfile:
            writer = csv.writer(csvfile)
            writer.writerow(["CVE", "Quay", "RedHat", "Description", "Statement"])
            for cve, result in results.items():
                writer.writerow(
                    [
                        cve,
                        result.quay,
                        result.redhat or "NOT_FOUND",
                        result.description or "",
                        result.statement or "",
                    ]
                )
    else:
        for cve, result in results.items():
            print(
                f"ID: {cve}, Quay: {result.quay}, RedHat: {result.redhat or 'Not found ⚠️'}"
            )


def main() -> None:
    parser = argparse.ArgumentParser(description="CVE Mapper")
    parser.add_argument(
        "input", help="Path to JSON file or directory containing JSON files"
    )
    parser.add_argument("-o", "--output", help="Path to CSV file to write results to")
    parser.add_argument(
        "-c",
        "--confluence",
        nargs=2,
        help="Confluence credentials and space key: <base_url> <api_token> <space_key>",
    )

    args = parser.parse_args()

    if args.confluence:
        create_confluence_page(
            args.confluence[0],
            args.confluence[1],
            args.confluence[2],
            args.input,
            args.output,
        )
    else:
        process_json(args.input, args.output)


if __name__ == "__main__":
    main()
